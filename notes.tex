\documentclass{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage[fleqn]{amsmath}
\usepackage{amssymb}
\usepackage{parskip}
\usepackage{graphicx}

\usepackage{listings}
\lstset{language=Octave, basicstyle=\tt, tabsize=8,
  breaklines=true, caption=\texttt\lstname, captionpos=b}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
{<5><6><7><8><9><10><10.95><12><14.4><17.28><20.74><24.88>cmttb10}{}

\begin{document}

\title{Numerische Mathematik UE -- 2. Projekt, Teilprojekt 1 und 2}
\author{Gabriel Ebner, Johannes Hafner}
\maketitle

\section{Theoretischer Teil}

\subsection{Singulärwertzerlegung}

Wir haben \(D = \mathrm{diag}(1,2,3,\epsilon)\) und \(U=V\) wie folgt gewählt:

\[ U = \frac 1 2 \left( \begin{array}{rrrr}
 1 &  1 &  1 &  1 \\
 1 & -1 & -1 &  1 \\
 1 &  1 & -1 & -1 \\
 1 & -1 &  1 & -1
\end{array} \right) \]

Offensichtlich haben wir \(\mathrm{cond}(UDV^T) = \frac 3 \epsilon\).

\subsection{Eigenwertzerlegung}

Als Beispiel einer Matrix in Eigenwertzerlegung mit gutkonditionierter
Transformationsmatrix und betragskleinen Eigenwerten haben wir die Matrix
\(UDV^T = UDU^{-1}\) von oben gewählt.

Bla bla bla

\subsection{Vandermondematrix}

Wir haben eine Vandermondematrix zu den vier Stützstellen \(1 + \epsilon i\)
(\(1 \leq i \leq 4\)) gewählt.

\section{Experimenteller Teil}

\subsection{Fehlerverläufe und Konditionen}

\begin{figure}[!htb]
\centering
\includegraphics{fig_svd.pdf}
\caption{Matrix in Singulärwertzerlegung: Fehler beim Lösen des LSG, Kondition von \(UDV^T\). }
\label{fig:svd}
\end{figure}

\begin{figure}[!htb]
\centering
\includegraphics{fig_eig.pdf}
\caption{Matrix in Eigenwertzerlegung: Fehler beim Lösen des LSG, Kondition von \(X \Lambda X^{-1}\), Kondition von \(X\). }
\label{fig:eig}
\end{figure}

\begin{figure}[!htb]
\centering
\includegraphics{fig_vander.pdf}
\caption{Vandermondematrix: Fehler beim Lösen des LSG, Kondition von \(A\). }
\label{fig:vander}
\end{figure}

Um die Rechenfehler zu bestimmen, haben wir für jede Matrix zunächst das LGS
gelöst, dann wieder die Matrix angewendet, und dann den relativen Fehler zum
ursprünglichen Vektor berechnet und geplottet.  Bei der Matrix in
Eigenwerzerlegung haben wir darüberhinaus auch noch die Kondition der
Transformationsmatrix geplottet.

Wir haben auch versucht, Rechenfehler beim Lösen eines LGS mit einer
orthogonalen Systemmatrix zu erreichen.  Dazu haben wir eine Householder-Matrix
mit einem zufälligen Vektor genommen, und den relativen Fehler beim Lösen mit
einem anderem zufälligen Vektor berechnet:

\begin{verbatim}
octave:26> errsolve(householder(randn(1000,1)), randn(1000,1))
ans =  1.2240e-15
\end{verbatim}

Bei anderen orthogonalen Matrizen haben wir generell bessere Ergebnisse
bekommen, zum Teil sogar exakte Lösungen.

\subsection{Fehlermeldungen}

Octave gibt erwartungsgemäß die Fehlermeldung \texttt{matrix singular to
machine precision} bei entsprechend kleinem \(\epsilon\) aus; bei der Matrix in
Eigenwertzerlegung ab \(\epsilon \leq 2^{-15}\), bei der Vandermondematrix ab
\(\epsilon \leq 2^{-17}\), und bei der Matrix in Singulärwertzerlegung ab
\(\epsilon \leq 2^{-51}\).

\subsection{Betriebsmittel}

Die Berechnungen wurden mit double precision unter Octave 3.2.4 und Ubuntu
Oneiric (amd64) auf einem AMD Phenom II X4 965 Prozessor durchgeführt.

\subsubsection{Quelltext}

\lstinputlisting{eigm.m}
\lstinputlisting{eigv.m}
\lstinputlisting{svdm.m}
\lstinputlisting{svdv.m}
\lstinputlisting{vanderm.m}
\lstinputlisting{vanderv.m}
\lstinputlisting{householder.m}
\lstinputlisting{errsolve.m}
\lstinputlisting{ploterrs.m}
\lstinputlisting{ploterrs_eig.m}
\lstinputlisting{plots.m}

\end{document}
